// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.9.0
//   protoc        v3.20.3

import { Writer, Reader } from "as-proto/assembly";

export namespace asproto {
  export namespace test {
    @unmanaged
    export class Empty {
      static encode(message: Empty, writer: Writer): void {}

      static decode(reader: Reader, length: i32): Empty {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new Empty();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      constructor() {}
    }

    @unmanaged
    export class EnumContainer {
      static encode(message: EnumContainer, writer: Writer): void {
        writer.uint32(8);
        writer.int32(message.outerEnum);
      }

      static decode(reader: Reader, length: i32): EnumContainer {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new EnumContainer();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.outerEnum = reader.int32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      outerEnum: asproto.test.OuterEnum;

      constructor(outerEnum: asproto.test.OuterEnum = 0) {
        this.outerEnum = outerEnum;
      }
    }

    export class Simple1 {
      static encode(message: Simple1, writer: Writer): void {
        writer.uint32(10);
        writer.string(message.aString);

        const aRepeatedString = message.aRepeatedString;
        if (aRepeatedString.length !== 0) {
          for (let i: i32 = 0; i < aRepeatedString.length; ++i) {
            writer.uint32(18);
            writer.string(aRepeatedString[i]);
          }
        }

        writer.uint32(24);
        writer.bool(message.aBoolean);
      }

      static decode(reader: Reader, length: i32): Simple1 {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new Simple1();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aString = reader.string();
              break;

            case 2:
              message.aRepeatedString.push(reader.string());
              break;

            case 3:
              message.aBoolean = reader.bool();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      aString: string;
      aRepeatedString: Array<string>;
      aBoolean: bool;

      constructor(
        aString: string = "",
        aRepeatedString: Array<string> = [],
        aBoolean: bool = false
      ) {
        this.aString = aString;
        this.aRepeatedString = aRepeatedString;
        this.aBoolean = aBoolean;
      }
    }

    export class Simple2 {
      static encode(message: Simple2, writer: Writer): void {
        writer.uint32(10);
        writer.string(message.aString);

        const aRepeatedString = message.aRepeatedString;
        if (aRepeatedString.length !== 0) {
          for (let i: i32 = 0; i < aRepeatedString.length; ++i) {
            writer.uint32(18);
            writer.string(aRepeatedString[i]);
          }
        }
      }

      static decode(reader: Reader, length: i32): Simple2 {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new Simple2();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aString = reader.string();
              break;

            case 2:
              message.aRepeatedString.push(reader.string());
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      aString: string;
      aRepeatedString: Array<string>;

      constructor(aString: string = "", aRepeatedString: Array<string> = []) {
        this.aString = aString;
        this.aRepeatedString = aRepeatedString;
      }
    }

    export class SpecialCases {
      static encode(message: SpecialCases, writer: Writer): void {
        writer.uint32(10);
        writer.string(message.normal);

        writer.uint32(18);
        writer.string(message.default);

        writer.uint32(26);
        writer.string(message.function);

        writer.uint32(34);
        writer.string(message.var);
      }

      static decode(reader: Reader, length: i32): SpecialCases {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new SpecialCases();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.normal = reader.string();
              break;

            case 2:
              message.default = reader.string();
              break;

            case 3:
              message.function = reader.string();
              break;

            case 4:
              message.var = reader.string();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      normal: string;
      default: string;
      function: string;
      var: string;

      constructor(
        normal: string = "",
        default_: string = "",
        function_: string = "",
        var_: string = ""
      ) {
        this.normal = normal;
        this.default = default_;
        this.function = function_;
        this.var = var_;
      }
    }

    export class OptionalFields {
      static encode(message: OptionalFields, writer: Writer): void {
        writer.uint32(10);
        writer.string(message.aString);

        writer.uint32(16);
        writer.bool(message.aBool);

        const aNestedMessage = message.aNestedMessage;
        if (aNestedMessage !== null) {
          writer.uint32(26);
          writer.fork();
          asproto.test.OptionalFields.Nested.encode(aNestedMessage, writer);
          writer.ldelim();
        }

        const aRepeatedMessage = message.aRepeatedMessage;
        for (let i: i32 = 0; i < aRepeatedMessage.length; ++i) {
          writer.uint32(34);
          writer.fork();
          asproto.test.OptionalFields.Nested.encode(
            aRepeatedMessage[i],
            writer
          );
          writer.ldelim();
        }

        const aRepeatedString = message.aRepeatedString;
        if (aRepeatedString.length !== 0) {
          for (let i: i32 = 0; i < aRepeatedString.length; ++i) {
            writer.uint32(42);
            writer.string(aRepeatedString[i]);
          }
        }
      }

      static decode(reader: Reader, length: i32): OptionalFields {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new OptionalFields();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aString = reader.string();
              break;

            case 2:
              message.aBool = reader.bool();
              break;

            case 3:
              message.aNestedMessage =
                asproto.test.OptionalFields.Nested.decode(
                  reader,
                  reader.uint32()
                );
              break;

            case 4:
              message.aRepeatedMessage.push(
                asproto.test.OptionalFields.Nested.decode(
                  reader,
                  reader.uint32()
                )
              );
              break;

            case 5:
              message.aRepeatedString.push(reader.string());
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      aString: string;
      aBool: bool;
      aNestedMessage: asproto.test.OptionalFields.Nested | null;
      aRepeatedMessage: Array<asproto.test.OptionalFields.Nested>;
      aRepeatedString: Array<string>;

      constructor(
        aString: string = "",
        aBool: bool = false,
        aNestedMessage: asproto.test.OptionalFields.Nested | null = null,
        aRepeatedMessage: Array<asproto.test.OptionalFields.Nested> = [],
        aRepeatedString: Array<string> = []
      ) {
        this.aString = aString;
        this.aBool = aBool;
        this.aNestedMessage = aNestedMessage;
        this.aRepeatedMessage = aRepeatedMessage;
        this.aRepeatedString = aRepeatedString;
      }
    }

    export namespace OptionalFields {
      @unmanaged
      export class Nested {
        static encode(message: Nested, writer: Writer): void {
          writer.uint32(8);
          writer.int32(message.anInt);
        }

        static decode(reader: Reader, length: i32): Nested {
          const end: usize = length < 0 ? reader.end : reader.ptr + length;
          const message = new Nested();

          while (reader.ptr < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.anInt = reader.int32();
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
          }

          return message;
        }

        anInt: i32;

        constructor(anInt: i32 = 0) {
          this.anInt = anInt;
        }
      }
    }

    export class HasExtensions {
      static encode(message: HasExtensions, writer: Writer): void {
        writer.uint32(10);
        writer.string(message.str1);

        writer.uint32(18);
        writer.string(message.str2);

        writer.uint32(26);
        writer.string(message.str3);
      }

      static decode(reader: Reader, length: i32): HasExtensions {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new HasExtensions();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.str1 = reader.string();
              break;

            case 2:
              message.str2 = reader.string();
              break;

            case 3:
              message.str3 = reader.string();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      str1: string;
      str2: string;
      str3: string;

      constructor(str1: string = "", str2: string = "", str3: string = "") {
        this.str1 = str1;
        this.str2 = str2;
        this.str3 = str3;
      }
    }

    export class Complex {
      static encode(message: Complex, writer: Writer): void {
        writer.uint32(10);
        writer.string(message.aString);

        writer.uint32(72);
        writer.bool(message.anOutOfOrderBool);

        const aNestedMessage = message.aNestedMessage;
        if (aNestedMessage !== null) {
          writer.uint32(34);
          writer.fork();
          asproto.test.Complex.Nested.encode(aNestedMessage, writer);
          writer.ldelim();
        }

        const aRepeatedMessage = message.aRepeatedMessage;
        for (let i: i32 = 0; i < aRepeatedMessage.length; ++i) {
          writer.uint32(42);
          writer.fork();
          asproto.test.Complex.Nested.encode(aRepeatedMessage[i], writer);
          writer.ldelim();
        }

        const aRepeatedString = message.aRepeatedString;
        if (aRepeatedString.length !== 0) {
          for (let i: i32 = 0; i < aRepeatedString.length; ++i) {
            writer.uint32(58);
            writer.string(aRepeatedString[i]);
          }
        }

        writer.uint32(81);
        writer.double(message.aFloatingPointField);
      }

      static decode(reader: Reader, length: i32): Complex {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new Complex();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aString = reader.string();
              break;

            case 9:
              message.anOutOfOrderBool = reader.bool();
              break;

            case 4:
              message.aNestedMessage = asproto.test.Complex.Nested.decode(
                reader,
                reader.uint32()
              );
              break;

            case 5:
              message.aRepeatedMessage.push(
                asproto.test.Complex.Nested.decode(reader, reader.uint32())
              );
              break;

            case 7:
              message.aRepeatedString.push(reader.string());
              break;

            case 10:
              message.aFloatingPointField = reader.double();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      aString: string;
      anOutOfOrderBool: bool;
      aNestedMessage: asproto.test.Complex.Nested | null;
      aRepeatedMessage: Array<asproto.test.Complex.Nested>;
      aRepeatedString: Array<string>;
      aFloatingPointField: f64;

      constructor(
        aString: string = "",
        anOutOfOrderBool: bool = false,
        aNestedMessage: asproto.test.Complex.Nested | null = null,
        aRepeatedMessage: Array<asproto.test.Complex.Nested> = [],
        aRepeatedString: Array<string> = [],
        aFloatingPointField: f64 = 0.0
      ) {
        this.aString = aString;
        this.anOutOfOrderBool = anOutOfOrderBool;
        this.aNestedMessage = aNestedMessage;
        this.aRepeatedMessage = aRepeatedMessage;
        this.aRepeatedString = aRepeatedString;
        this.aFloatingPointField = aFloatingPointField;
      }
    }

    export namespace Complex {
      @unmanaged
      export class Nested {
        static encode(message: Nested, writer: Writer): void {
          writer.uint32(16);
          writer.int32(message.anInt);
        }

        static decode(reader: Reader, length: i32): Nested {
          const end: usize = length < 0 ? reader.end : reader.ptr + length;
          const message = new Nested();

          while (reader.ptr < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 2:
                message.anInt = reader.int32();
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
          }

          return message;
        }

        anInt: i32;

        constructor(anInt: i32 = 0) {
          this.anInt = anInt;
        }
      }
    }

    @unmanaged
    export class OuterMessage {
      static encode(message: OuterMessage, writer: Writer): void {}

      static decode(reader: Reader, length: i32): OuterMessage {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new OuterMessage();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      constructor() {}
    }

    export namespace OuterMessage {
      @unmanaged
      export class Complex {
        static encode(message: Complex, writer: Writer): void {
          writer.uint32(8);
          writer.int32(message.innerComplexField);
        }

        static decode(reader: Reader, length: i32): Complex {
          const end: usize = length < 0 ? reader.end : reader.ptr + length;
          const message = new Complex();

          while (reader.ptr < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.innerComplexField = reader.int32();
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
          }

          return message;
        }

        innerComplexField: i32;

        constructor(innerComplexField: i32 = 0) {
          this.innerComplexField = innerComplexField;
        }
      }
    }

    export class MineField {
      static encode(message: MineField, writer: Writer): void {
        writer.uint32(10);
        writer.string(message.cookie);
      }

      static decode(reader: Reader, length: i32): MineField {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MineField();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cookie = reader.string();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      cookie: string;

      constructor(cookie: string = "") {
        this.cookie = cookie;
      }
    }

    export class IsExtension {
      static encode(message: IsExtension, writer: Writer): void {
        writer.uint32(10);
        writer.string(message.ext1);
      }

      static decode(reader: Reader, length: i32): IsExtension {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new IsExtension();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ext1 = reader.string();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      ext1: string;

      constructor(ext1: string = "") {
        this.ext1 = ext1;
      }
    }

    @unmanaged
    export class IndirectExtension {
      static encode(message: IndirectExtension, writer: Writer): void {}

      static decode(reader: Reader, length: i32): IndirectExtension {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new IndirectExtension();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      constructor() {}
    }

    export class DefaultValues {
      static encode(message: DefaultValues, writer: Writer): void {
        writer.uint32(10);
        writer.string(message.stringField);

        writer.uint32(16);
        writer.bool(message.boolField);

        writer.uint32(24);
        writer.int64(message.intField);

        writer.uint32(32);
        writer.int32(message.enumField);

        writer.uint32(50);
        writer.string(message.emptyField);

        writer.uint32(66);
        writer.bytes(message.bytesField);
      }

      static decode(reader: Reader, length: i32): DefaultValues {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new DefaultValues();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.stringField = reader.string();
              break;

            case 2:
              message.boolField = reader.bool();
              break;

            case 3:
              message.intField = reader.int64();
              break;

            case 4:
              message.enumField = reader.int32();
              break;

            case 6:
              message.emptyField = reader.string();
              break;

            case 8:
              message.bytesField = reader.bytes();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      stringField: string;
      boolField: bool;
      intField: i64;
      enumField: asproto.test.DefaultValues.Enum;
      emptyField: string;
      bytesField: Uint8Array;

      constructor(
        stringField: string = "default<>'\"abc",
        boolField: bool = true,
        intField: i64 = 11,
        enumField: asproto.test.DefaultValues.Enum = asproto.test.DefaultValues
          .Enum.E1,
        emptyField: string = "",
        bytesField: Uint8Array = new Uint8Array(0)
      ) {
        this.stringField = stringField;
        this.boolField = boolField;
        this.intField = intField;
        this.enumField = enumField;
        this.emptyField = emptyField;
        this.bytesField = bytesField;
      }
    }

    export namespace DefaultValues {
      export enum Enum {
        E1 = 13,
        E2 = 77,
      }
    }

    export class FloatingPointFields {
      static encode(message: FloatingPointFields, writer: Writer): void {
        writer.uint32(13);
        writer.float(message.optionalFloatField);

        writer.uint32(21);
        writer.float(message.requiredFloatField);

        const repeatedFloatField = message.repeatedFloatField;
        if (repeatedFloatField.length !== 0) {
          for (let i: i32 = 0; i < repeatedFloatField.length; ++i) {
            writer.uint32(29);
            writer.float(repeatedFloatField[i]);
          }
        }

        writer.uint32(37);
        writer.float(message.defaultFloatField);

        writer.uint32(41);
        writer.double(message.optionalDoubleField);

        writer.uint32(49);
        writer.double(message.requiredDoubleField);

        const repeatedDoubleField = message.repeatedDoubleField;
        if (repeatedDoubleField.length !== 0) {
          for (let i: i32 = 0; i < repeatedDoubleField.length; ++i) {
            writer.uint32(57);
            writer.double(repeatedDoubleField[i]);
          }
        }

        writer.uint32(65);
        writer.double(message.defaultDoubleField);
      }

      static decode(reader: Reader, length: i32): FloatingPointFields {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new FloatingPointFields();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.optionalFloatField = reader.float();
              break;

            case 2:
              message.requiredFloatField = reader.float();
              break;

            case 3:
              message.repeatedFloatField.push(reader.float());
              break;

            case 4:
              message.defaultFloatField = reader.float();
              break;

            case 5:
              message.optionalDoubleField = reader.double();
              break;

            case 6:
              message.requiredDoubleField = reader.double();
              break;

            case 7:
              message.repeatedDoubleField.push(reader.double());
              break;

            case 8:
              message.defaultDoubleField = reader.double();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      optionalFloatField: f32;
      requiredFloatField: f32;
      repeatedFloatField: Array<f32>;
      defaultFloatField: f32;
      optionalDoubleField: f64;
      requiredDoubleField: f64;
      repeatedDoubleField: Array<f64>;
      defaultDoubleField: f64;

      constructor(
        optionalFloatField: f32 = 0.0,
        requiredFloatField: f32 = 0.0,
        repeatedFloatField: Array<f32> = [],
        defaultFloatField: f32 = 2,
        optionalDoubleField: f64 = 0.0,
        requiredDoubleField: f64 = 0.0,
        repeatedDoubleField: Array<f64> = [],
        defaultDoubleField: f64 = 2
      ) {
        this.optionalFloatField = optionalFloatField;
        this.requiredFloatField = requiredFloatField;
        this.repeatedFloatField = repeatedFloatField;
        this.defaultFloatField = defaultFloatField;
        this.optionalDoubleField = optionalDoubleField;
        this.requiredDoubleField = requiredDoubleField;
        this.repeatedDoubleField = repeatedDoubleField;
        this.defaultDoubleField = defaultDoubleField;
      }
    }

    export class BooleanFields {
      static encode(message: BooleanFields, writer: Writer): void {
        writer.uint32(8);
        writer.bool(message.optionalBooleanField);

        writer.uint32(16);
        writer.bool(message.requiredBooleanField);

        const repeatedBooleanField = message.repeatedBooleanField;
        if (repeatedBooleanField.length !== 0) {
          for (let i: i32 = 0; i < repeatedBooleanField.length; ++i) {
            writer.uint32(24);
            writer.bool(repeatedBooleanField[i]);
          }
        }

        writer.uint32(32);
        writer.bool(message.defaultBooleanField);
      }

      static decode(reader: Reader, length: i32): BooleanFields {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new BooleanFields();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.optionalBooleanField = reader.bool();
              break;

            case 2:
              message.requiredBooleanField = reader.bool();
              break;

            case 3:
              message.repeatedBooleanField.push(reader.bool());
              break;

            case 4:
              message.defaultBooleanField = reader.bool();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      optionalBooleanField: bool;
      requiredBooleanField: bool;
      repeatedBooleanField: Array<bool>;
      defaultBooleanField: bool;

      constructor(
        optionalBooleanField: bool = false,
        requiredBooleanField: bool = false,
        repeatedBooleanField: Array<bool> = [],
        defaultBooleanField: bool = true
      ) {
        this.optionalBooleanField = optionalBooleanField;
        this.requiredBooleanField = requiredBooleanField;
        this.repeatedBooleanField = repeatedBooleanField;
        this.defaultBooleanField = defaultBooleanField;
      }
    }

    export class TestClone {
      static encode(message: TestClone, writer: Writer): void {
        writer.uint32(10);
        writer.string(message.str);

        const simple1 = message.simple1;
        if (simple1 !== null) {
          writer.uint32(26);
          writer.fork();
          asproto.test.Simple1.encode(simple1, writer);
          writer.ldelim();
        }

        const simple2 = message.simple2;
        for (let i: i32 = 0; i < simple2.length; ++i) {
          writer.uint32(42);
          writer.fork();
          asproto.test.Simple1.encode(simple2[i], writer);
          writer.ldelim();
        }

        writer.uint32(50);
        writer.bytes(message.bytesField);

        writer.uint32(58);
        writer.string(message.unused);
      }

      static decode(reader: Reader, length: i32): TestClone {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestClone();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.str = reader.string();
              break;

            case 3:
              message.simple1 = asproto.test.Simple1.decode(
                reader,
                reader.uint32()
              );
              break;

            case 5:
              message.simple2.push(
                asproto.test.Simple1.decode(reader, reader.uint32())
              );
              break;

            case 6:
              message.bytesField = reader.bytes();
              break;

            case 7:
              message.unused = reader.string();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      str: string;
      simple1: asproto.test.Simple1 | null;
      simple2: Array<asproto.test.Simple1>;
      bytesField: Uint8Array;
      unused: string;

      constructor(
        str: string = "",
        simple1: asproto.test.Simple1 | null = null,
        simple2: Array<asproto.test.Simple1> = [],
        bytesField: Uint8Array = new Uint8Array(0),
        unused: string = ""
      ) {
        this.str = str;
        this.simple1 = simple1;
        this.simple2 = simple2;
        this.bytesField = bytesField;
        this.unused = unused;
      }
    }

    @unmanaged
    export class TestCloneExtension {
      static encode(message: TestCloneExtension, writer: Writer): void {
        writer.uint32(8);
        writer.int32(message.f);
      }

      static decode(reader: Reader, length: i32): TestCloneExtension {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestCloneExtension();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.f = reader.int32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      f: i32;

      constructor(f: i32 = 0) {
        this.f = f;
      }
    }

    export class CloneExtension {
      static encode(message: CloneExtension, writer: Writer): void {
        writer.uint32(18);
        writer.string(message.ext);
      }

      static decode(reader: Reader, length: i32): CloneExtension {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new CloneExtension();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.ext = reader.string();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      ext: string;

      constructor(ext: string = "") {
        this.ext = ext;
      }
    }

    @unmanaged
    export class TestReservedNames {
      static encode(message: TestReservedNames, writer: Writer): void {
        writer.uint32(8);
        writer.int32(message.extension);
      }

      static decode(reader: Reader, length: i32): TestReservedNames {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestReservedNames();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.extension = reader.int32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      extension: i32;

      constructor(extension: i32 = 0) {
        this.extension = extension;
      }
    }

    @unmanaged
    export class TestReservedNamesExtension {
      static encode(
        message: TestReservedNamesExtension,
        writer: Writer
      ): void {}

      static decode(reader: Reader, length: i32): TestReservedNamesExtension {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestReservedNamesExtension();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      constructor() {}
    }

    export class TestMessageWithOneof {
      static encode(message: TestMessageWithOneof, writer: Writer): void {
        writer.uint32(26);
        writer.string(message.pone);

        writer.uint32(42);
        writer.string(message.pthree);

        const rone = message.rone;
        if (rone !== null) {
          writer.uint32(50);
          writer.fork();
          asproto.test.TestMessageWithOneof.encode(rone, writer);
          writer.ldelim();
        }

        writer.uint32(58);
        writer.string(message.rtwo);

        writer.uint32(64);
        writer.bool(message.normalField);

        const repeatedField = message.repeatedField;
        if (repeatedField.length !== 0) {
          for (let i: i32 = 0; i < repeatedField.length; ++i) {
            writer.uint32(74);
            writer.string(repeatedField[i]);
          }
        }

        writer.uint32(80);
        writer.int32(message.aone);

        writer.uint32(88);
        writer.int32(message.atwo);

        writer.uint32(96);
        writer.int32(message.bone);

        writer.uint32(104);
        writer.int32(message.btwo);
      }

      static decode(reader: Reader, length: i32): TestMessageWithOneof {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestMessageWithOneof();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.pone = reader.string();
              break;

            case 5:
              message.pthree = reader.string();
              break;

            case 6:
              message.rone = asproto.test.TestMessageWithOneof.decode(
                reader,
                reader.uint32()
              );
              break;

            case 7:
              message.rtwo = reader.string();
              break;

            case 8:
              message.normalField = reader.bool();
              break;

            case 9:
              message.repeatedField.push(reader.string());
              break;

            case 10:
              message.aone = reader.int32();
              break;

            case 11:
              message.atwo = reader.int32();
              break;

            case 12:
              message.bone = reader.int32();
              break;

            case 13:
              message.btwo = reader.int32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      pone: string;
      pthree: string;
      rone: asproto.test.TestMessageWithOneof | null;
      rtwo: string;
      normalField: bool;
      repeatedField: Array<string>;
      aone: i32;
      atwo: i32;
      bone: i32;
      btwo: i32;

      constructor(
        pone: string = "",
        pthree: string = "",
        rone: asproto.test.TestMessageWithOneof | null = null,
        rtwo: string = "",
        normalField: bool = false,
        repeatedField: Array<string> = [],
        aone: i32 = 1234,
        atwo: i32 = 0,
        bone: i32 = 0,
        btwo: i32 = 1234
      ) {
        this.pone = pone;
        this.pthree = pthree;
        this.rone = rone;
        this.rtwo = rtwo;
        this.normalField = normalField;
        this.repeatedField = repeatedField;
        this.aone = aone;
        this.atwo = atwo;
        this.bone = bone;
        this.btwo = btwo;
      }
    }

    export class TestEndsWithBytes {
      static encode(message: TestEndsWithBytes, writer: Writer): void {
        writer.uint32(8);
        writer.int32(message.value);

        writer.uint32(18);
        writer.bytes(message.data);
      }

      static decode(reader: Reader, length: i32): TestEndsWithBytes {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestEndsWithBytes();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.value = reader.int32();
              break;

            case 2:
              message.data = reader.bytes();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      value: i32;
      data: Uint8Array;

      constructor(value: i32 = 0, data: Uint8Array = new Uint8Array(0)) {
        this.value = value;
        this.data = data;
      }
    }

    @unmanaged
    export class TestLastFieldBeforePivot {
      static encode(message: TestLastFieldBeforePivot, writer: Writer): void {
        writer.uint32(8);
        writer.int32(message.lastFieldBeforePivot);
      }

      static decode(reader: Reader, length: i32): TestLastFieldBeforePivot {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestLastFieldBeforePivot();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.lastFieldBeforePivot = reader.int32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      lastFieldBeforePivot: i32;

      constructor(lastFieldBeforePivot: i32 = 0) {
        this.lastFieldBeforePivot = lastFieldBeforePivot;
      }
    }

    @unmanaged
    export class Int64Types {
      static encode(message: Int64Types, writer: Writer): void {
        writer.uint32(8);
        writer.int64(message.int64Normal);

        writer.uint32(16);
        writer.sint64(message.int64String);

        writer.uint32(24);
        writer.uint64(message.int64Number);
      }

      static decode(reader: Reader, length: i32): Int64Types {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new Int64Types();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.int64Normal = reader.int64();
              break;

            case 2:
              message.int64String = reader.sint64();
              break;

            case 3:
              message.int64Number = reader.uint64();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      int64Normal: i64;
      int64String: i64;
      int64Number: u64;

      constructor(
        int64Normal: i64 = 0,
        int64String: i64 = 0,
        int64Number: u64 = 0
      ) {
        this.int64Normal = int64Normal;
        this.int64String = int64String;
        this.int64Number = int64Number;
      }
    }

    export class TestMapFieldsNoBinary {
      static encode(message: TestMapFieldsNoBinary, writer: Writer): void {
        const mapStringString = message.mapStringString;
        if (mapStringString !== null) {
          const mapStringStringKeys = mapStringString.keys();
          for (let i: i32 = 0; i < mapStringStringKeys.length; ++i) {
            const mapStringStringKey = mapStringStringKeys[i];
            writer.uint32(10);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringStringKey);
            writer.uint32(18);
            writer.string(mapStringString.get(mapStringStringKey));
            writer.ldelim();
          }
        }

        const mapStringInt32 = message.mapStringInt32;
        if (mapStringInt32 !== null) {
          const mapStringInt32Keys = mapStringInt32.keys();
          for (let i: i32 = 0; i < mapStringInt32Keys.length; ++i) {
            const mapStringInt32Key = mapStringInt32Keys[i];
            writer.uint32(18);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringInt32Key);
            writer.uint32(16);
            writer.int32(mapStringInt32.get(mapStringInt32Key));
            writer.ldelim();
          }
        }

        const mapStringInt64 = message.mapStringInt64;
        if (mapStringInt64 !== null) {
          const mapStringInt64Keys = mapStringInt64.keys();
          for (let i: i32 = 0; i < mapStringInt64Keys.length; ++i) {
            const mapStringInt64Key = mapStringInt64Keys[i];
            writer.uint32(26);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringInt64Key);
            writer.uint32(16);
            writer.int64(mapStringInt64.get(mapStringInt64Key));
            writer.ldelim();
          }
        }

        const mapStringBool = message.mapStringBool;
        if (mapStringBool !== null) {
          const mapStringBoolKeys = mapStringBool.keys();
          for (let i: i32 = 0; i < mapStringBoolKeys.length; ++i) {
            const mapStringBoolKey = mapStringBoolKeys[i];
            writer.uint32(34);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringBoolKey);
            writer.uint32(16);
            writer.bool(mapStringBool.get(mapStringBoolKey));
            writer.ldelim();
          }
        }

        const mapStringDouble = message.mapStringDouble;
        if (mapStringDouble !== null) {
          const mapStringDoubleKeys = mapStringDouble.keys();
          for (let i: i32 = 0; i < mapStringDoubleKeys.length; ++i) {
            const mapStringDoubleKey = mapStringDoubleKeys[i];
            writer.uint32(42);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringDoubleKey);
            writer.uint32(17);
            writer.double(mapStringDouble.get(mapStringDoubleKey));
            writer.ldelim();
          }
        }

        const mapStringEnum = message.mapStringEnum;
        if (mapStringEnum !== null) {
          const mapStringEnumKeys = mapStringEnum.keys();
          for (let i: i32 = 0; i < mapStringEnumKeys.length; ++i) {
            const mapStringEnumKey = mapStringEnumKeys[i];
            writer.uint32(50);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringEnumKey);
            writer.uint32(16);
            writer.int32(mapStringEnum.get(mapStringEnumKey));
            writer.ldelim();
          }
        }

        const mapStringMsg = message.mapStringMsg;
        if (mapStringMsg !== null) {
          const mapStringMsgKeys = mapStringMsg.keys();
          for (let i: i32 = 0; i < mapStringMsgKeys.length; ++i) {
            const mapStringMsgKey = mapStringMsgKeys[i];
            writer.uint32(58);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringMsgKey);
            writer.uint32(18);
            writer.fork();
            asproto.test.MapValueMessageNoBinary.encode(
              mapStringMsg.get(mapStringMsgKey),
              writer
            );
            writer.ldelim();
            writer.ldelim();
          }
        }

        const mapInt32String = message.mapInt32String;
        if (mapInt32String !== null) {
          const mapInt32StringKeys = mapInt32String.keys();
          for (let i: i32 = 0; i < mapInt32StringKeys.length; ++i) {
            const mapInt32StringKey = mapInt32StringKeys[i];
            writer.uint32(66);
            writer.fork();
            writer.uint32(8);
            writer.int32(mapInt32StringKey);
            writer.uint32(18);
            writer.string(mapInt32String.get(mapInt32StringKey));
            writer.ldelim();
          }
        }

        const mapInt64String = message.mapInt64String;
        if (mapInt64String !== null) {
          const mapInt64StringKeys = mapInt64String.keys();
          for (let i: i32 = 0; i < mapInt64StringKeys.length; ++i) {
            const mapInt64StringKey = mapInt64StringKeys[i];
            writer.uint32(74);
            writer.fork();
            writer.uint32(8);
            writer.int64(mapInt64StringKey);
            writer.uint32(18);
            writer.string(mapInt64String.get(mapInt64StringKey));
            writer.ldelim();
          }
        }

        const mapBoolString = message.mapBoolString;
        if (mapBoolString !== null) {
          const mapBoolStringKeys = mapBoolString.keys();
          for (let i: i32 = 0; i < mapBoolStringKeys.length; ++i) {
            const mapBoolStringKey = mapBoolStringKeys[i];
            writer.uint32(82);
            writer.fork();
            writer.uint32(8);
            writer.bool(mapBoolStringKey);
            writer.uint32(18);
            writer.string(mapBoolString.get(mapBoolStringKey));
            writer.ldelim();
          }
        }

        const testMapFields = message.testMapFields;
        if (testMapFields !== null) {
          writer.uint32(90);
          writer.fork();
          asproto.test.TestMapFieldsNoBinary.encode(testMapFields, writer);
          writer.ldelim();
        }

        const mapStringTestmapfields = message.mapStringTestmapfields;
        if (mapStringTestmapfields !== null) {
          const mapStringTestmapfieldsKeys = mapStringTestmapfields.keys();
          for (let i: i32 = 0; i < mapStringTestmapfieldsKeys.length; ++i) {
            const mapStringTestmapfieldsKey = mapStringTestmapfieldsKeys[i];
            writer.uint32(98);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringTestmapfieldsKey);
            writer.uint32(18);
            writer.fork();
            asproto.test.TestMapFieldsNoBinary.encode(
              mapStringTestmapfields.get(mapStringTestmapfieldsKey),
              writer
            );
            writer.ldelim();
            writer.ldelim();
          }
        }
      }

      static decode(reader: Reader, length: i32): TestMapFieldsNoBinary {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestMapFieldsNoBinary();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              let mapStringStringKey: string = "";
              let mapStringStringValue: string = "";
              let mapStringStringHasKey: bool = false;
              let mapStringStringHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringStringKey = reader.string();
                    mapStringStringHasKey = true;
                    break;

                  case 2:
                    mapStringStringValue = reader.string();
                    mapStringStringHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringString === null) {
                  message.mapStringString = new Map<string, string>();
                }
                const mapStringString = message.mapStringString;
                if (
                  mapStringString !== null &&
                  mapStringStringHasKey &&
                  mapStringStringHasValue
                ) {
                  mapStringString.set(mapStringStringKey, mapStringStringValue);
                }
              }
              break;

            case 2:
              let mapStringInt32Key: string = "";
              let mapStringInt32Value: i32 = 0;
              let mapStringInt32HasKey: bool = false;
              let mapStringInt32HasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringInt32Key = reader.string();
                    mapStringInt32HasKey = true;
                    break;

                  case 2:
                    mapStringInt32Value = reader.int32();
                    mapStringInt32HasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringInt32 === null) {
                  message.mapStringInt32 = new Map<string, i32>();
                }
                const mapStringInt32 = message.mapStringInt32;
                if (
                  mapStringInt32 !== null &&
                  mapStringInt32HasKey &&
                  mapStringInt32HasValue
                ) {
                  mapStringInt32.set(mapStringInt32Key, mapStringInt32Value);
                }
              }
              break;

            case 3:
              let mapStringInt64Key: string = "";
              let mapStringInt64Value: i64 = 0;
              let mapStringInt64HasKey: bool = false;
              let mapStringInt64HasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringInt64Key = reader.string();
                    mapStringInt64HasKey = true;
                    break;

                  case 2:
                    mapStringInt64Value = reader.int64();
                    mapStringInt64HasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringInt64 === null) {
                  message.mapStringInt64 = new Map<string, i64>();
                }
                const mapStringInt64 = message.mapStringInt64;
                if (
                  mapStringInt64 !== null &&
                  mapStringInt64HasKey &&
                  mapStringInt64HasValue
                ) {
                  mapStringInt64.set(mapStringInt64Key, mapStringInt64Value);
                }
              }
              break;

            case 4:
              let mapStringBoolKey: string = "";
              let mapStringBoolValue: bool = false;
              let mapStringBoolHasKey: bool = false;
              let mapStringBoolHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringBoolKey = reader.string();
                    mapStringBoolHasKey = true;
                    break;

                  case 2:
                    mapStringBoolValue = reader.bool();
                    mapStringBoolHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringBool === null) {
                  message.mapStringBool = new Map<string, bool>();
                }
                const mapStringBool = message.mapStringBool;
                if (
                  mapStringBool !== null &&
                  mapStringBoolHasKey &&
                  mapStringBoolHasValue
                ) {
                  mapStringBool.set(mapStringBoolKey, mapStringBoolValue);
                }
              }
              break;

            case 5:
              let mapStringDoubleKey: string = "";
              let mapStringDoubleValue: f64 = 0.0;
              let mapStringDoubleHasKey: bool = false;
              let mapStringDoubleHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringDoubleKey = reader.string();
                    mapStringDoubleHasKey = true;
                    break;

                  case 2:
                    mapStringDoubleValue = reader.double();
                    mapStringDoubleHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringDouble === null) {
                  message.mapStringDouble = new Map<string, f64>();
                }
                const mapStringDouble = message.mapStringDouble;
                if (
                  mapStringDouble !== null &&
                  mapStringDoubleHasKey &&
                  mapStringDoubleHasValue
                ) {
                  mapStringDouble.set(mapStringDoubleKey, mapStringDoubleValue);
                }
              }
              break;

            case 6:
              let mapStringEnumKey: string = "";
              let mapStringEnumValue: asproto.test.MapValueEnumNoBinary = 0;
              let mapStringEnumHasKey: bool = false;
              let mapStringEnumHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringEnumKey = reader.string();
                    mapStringEnumHasKey = true;
                    break;

                  case 2:
                    mapStringEnumValue = reader.int32();
                    mapStringEnumHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringEnum === null) {
                  message.mapStringEnum = new Map<
                    string,
                    asproto.test.MapValueEnumNoBinary
                  >();
                }
                const mapStringEnum = message.mapStringEnum;
                if (
                  mapStringEnum !== null &&
                  mapStringEnumHasKey &&
                  mapStringEnumHasValue
                ) {
                  mapStringEnum.set(mapStringEnumKey, mapStringEnumValue);
                }
              }
              break;

            case 7:
              let mapStringMsgKey: string = "";
              let mapStringMsgValue: asproto.test.MapValueMessageNoBinary | null =
                null;
              let mapStringMsgHasKey: bool = false;
              let mapStringMsgHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringMsgKey = reader.string();
                    mapStringMsgHasKey = true;
                    break;

                  case 2:
                    mapStringMsgValue =
                      asproto.test.MapValueMessageNoBinary.decode(
                        reader,
                        reader.uint32()
                      );
                    mapStringMsgHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringMsg === null) {
                  message.mapStringMsg = new Map<
                    string,
                    asproto.test.MapValueMessageNoBinary
                  >();
                }
                const mapStringMsg = message.mapStringMsg;
                if (
                  mapStringMsg !== null &&
                  mapStringMsgHasKey &&
                  mapStringMsgHasValue &&
                  mapStringMsgValue !== null
                ) {
                  mapStringMsg.set(mapStringMsgKey, mapStringMsgValue);
                }
              }
              break;

            case 8:
              let mapInt32StringKey: i32 = 0;
              let mapInt32StringValue: string = "";
              let mapInt32StringHasKey: bool = false;
              let mapInt32StringHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapInt32StringKey = reader.int32();
                    mapInt32StringHasKey = true;
                    break;

                  case 2:
                    mapInt32StringValue = reader.string();
                    mapInt32StringHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapInt32String === null) {
                  message.mapInt32String = new Map<i32, string>();
                }
                const mapInt32String = message.mapInt32String;
                if (
                  mapInt32String !== null &&
                  mapInt32StringHasKey &&
                  mapInt32StringHasValue
                ) {
                  mapInt32String.set(mapInt32StringKey, mapInt32StringValue);
                }
              }
              break;

            case 9:
              let mapInt64StringKey: i64 = 0;
              let mapInt64StringValue: string = "";
              let mapInt64StringHasKey: bool = false;
              let mapInt64StringHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapInt64StringKey = reader.int64();
                    mapInt64StringHasKey = true;
                    break;

                  case 2:
                    mapInt64StringValue = reader.string();
                    mapInt64StringHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapInt64String === null) {
                  message.mapInt64String = new Map<i64, string>();
                }
                const mapInt64String = message.mapInt64String;
                if (
                  mapInt64String !== null &&
                  mapInt64StringHasKey &&
                  mapInt64StringHasValue
                ) {
                  mapInt64String.set(mapInt64StringKey, mapInt64StringValue);
                }
              }
              break;

            case 10:
              let mapBoolStringKey: bool = false;
              let mapBoolStringValue: string = "";
              let mapBoolStringHasKey: bool = false;
              let mapBoolStringHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapBoolStringKey = reader.bool();
                    mapBoolStringHasKey = true;
                    break;

                  case 2:
                    mapBoolStringValue = reader.string();
                    mapBoolStringHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapBoolString === null) {
                  message.mapBoolString = new Map<bool, string>();
                }
                const mapBoolString = message.mapBoolString;
                if (
                  mapBoolString !== null &&
                  mapBoolStringHasKey &&
                  mapBoolStringHasValue
                ) {
                  mapBoolString.set(mapBoolStringKey, mapBoolStringValue);
                }
              }
              break;

            case 11:
              message.testMapFields = asproto.test.TestMapFieldsNoBinary.decode(
                reader,
                reader.uint32()
              );
              break;

            case 12:
              let mapStringTestmapfieldsKey: string = "";
              let mapStringTestmapfieldsValue: asproto.test.TestMapFieldsNoBinary | null =
                null;
              let mapStringTestmapfieldsHasKey: bool = false;
              let mapStringTestmapfieldsHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringTestmapfieldsKey = reader.string();
                    mapStringTestmapfieldsHasKey = true;
                    break;

                  case 2:
                    mapStringTestmapfieldsValue =
                      asproto.test.TestMapFieldsNoBinary.decode(
                        reader,
                        reader.uint32()
                      );
                    mapStringTestmapfieldsHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringTestmapfields === null) {
                  message.mapStringTestmapfields = new Map<
                    string,
                    asproto.test.TestMapFieldsNoBinary
                  >();
                }
                const mapStringTestmapfields = message.mapStringTestmapfields;
                if (
                  mapStringTestmapfields !== null &&
                  mapStringTestmapfieldsHasKey &&
                  mapStringTestmapfieldsHasValue &&
                  mapStringTestmapfieldsValue !== null
                ) {
                  mapStringTestmapfields.set(
                    mapStringTestmapfieldsKey,
                    mapStringTestmapfieldsValue
                  );
                }
              }
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      mapStringString: Map<string, string>;
      mapStringInt32: Map<string, i32>;
      mapStringInt64: Map<string, i64>;
      mapStringBool: Map<string, bool>;
      mapStringDouble: Map<string, f64>;
      mapStringEnum: Map<string, asproto.test.MapValueEnumNoBinary>;
      mapStringMsg: Map<string, asproto.test.MapValueMessageNoBinary>;
      mapInt32String: Map<i32, string>;
      mapInt64String: Map<i64, string>;
      mapBoolString: Map<bool, string>;
      testMapFields: asproto.test.TestMapFieldsNoBinary | null;
      mapStringTestmapfields: Map<string, asproto.test.TestMapFieldsNoBinary>;

      constructor(
        mapStringString: Map<string, string> = new Map(),
        mapStringInt32: Map<string, i32> = new Map(),
        mapStringInt64: Map<string, i64> = new Map(),
        mapStringBool: Map<string, bool> = new Map(),
        mapStringDouble: Map<string, f64> = new Map(),
        mapStringEnum: Map<
          string,
          asproto.test.MapValueEnumNoBinary
        > = new Map(),
        mapStringMsg: Map<
          string,
          asproto.test.MapValueMessageNoBinary
        > = new Map(),
        mapInt32String: Map<i32, string> = new Map(),
        mapInt64String: Map<i64, string> = new Map(),
        mapBoolString: Map<bool, string> = new Map(),
        testMapFields: asproto.test.TestMapFieldsNoBinary | null = null,
        mapStringTestmapfields: Map<
          string,
          asproto.test.TestMapFieldsNoBinary
        > = new Map()
      ) {
        this.mapStringString = mapStringString;
        this.mapStringInt32 = mapStringInt32;
        this.mapStringInt64 = mapStringInt64;
        this.mapStringBool = mapStringBool;
        this.mapStringDouble = mapStringDouble;
        this.mapStringEnum = mapStringEnum;
        this.mapStringMsg = mapStringMsg;
        this.mapInt32String = mapInt32String;
        this.mapInt64String = mapInt64String;
        this.mapBoolString = mapBoolString;
        this.testMapFields = testMapFields;
        this.mapStringTestmapfields = mapStringTestmapfields;
      }
    }

    export namespace TestMapFieldsNoBinary {}

    @unmanaged
    export class MapValueMessageNoBinary {
      static encode(message: MapValueMessageNoBinary, writer: Writer): void {
        writer.uint32(8);
        writer.int32(message.foo);
      }

      static decode(reader: Reader, length: i32): MapValueMessageNoBinary {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapValueMessageNoBinary();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.foo = reader.int32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      foo: i32;

      constructor(foo: i32 = 0) {
        this.foo = foo;
      }
    }

    @unmanaged
    export class Deeply {
      static encode(message: Deeply, writer: Writer): void {}

      static decode(reader: Reader, length: i32): Deeply {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new Deeply();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      constructor() {}
    }

    export namespace Deeply {
      @unmanaged
      export class Nested {
        static encode(message: Nested, writer: Writer): void {}

        static decode(reader: Reader, length: i32): Nested {
          const end: usize = length < 0 ? reader.end : reader.ptr + length;
          const message = new Nested();

          while (reader.ptr < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              default:
                reader.skipType(tag & 7);
                break;
            }
          }

          return message;
        }

        constructor() {}
      }

      export namespace Nested {
        @unmanaged
        export class Message {
          static encode(message: Message, writer: Writer): void {
            writer.uint32(8);
            writer.int32(message.count);
          }

          static decode(reader: Reader, length: i32): Message {
            const end: usize = length < 0 ? reader.end : reader.ptr + length;
            const message = new Message();

            while (reader.ptr < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.count = reader.int32();
                  break;

                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }

            return message;
          }

          count: i32;

          constructor(count: i32 = 0) {
            this.count = count;
          }
        }
      }
    }

    export enum OuterEnum {
      FOO = 1,
      BAR = 2,
    }

    export enum MapValueEnumNoBinary {
      MAP_VALUE_FOO_NOBINARY = 0,
      MAP_VALUE_BAR_NOBINARY = 1,
      MAP_VALUE_BAZ_NOBINARY = 2,
    }

    export enum TestAllowAliasEnum {
      TEST_ALLOW_ALIAS_DEFAULT = 0,
      VALUE1 = 1,
      value1 = 1,
    }
  }
}
