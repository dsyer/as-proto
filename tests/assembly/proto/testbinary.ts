// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.9.0
//   protoc        v3.20.3

import { Writer, Reader } from "as-proto/assembly";

export namespace asproto {
  export namespace test {
    export class TestAllTypes {
      static encode(message: TestAllTypes, writer: Writer): void {
        const repeatedInt32 = message.repeatedInt32;
        if (repeatedInt32.length !== 0) {
          for (let i: i32 = 0; i < repeatedInt32.length; ++i) {
            writer.uint32(248);
            writer.int32(repeatedInt32[i]);
          }
        }

        const repeatedInt64 = message.repeatedInt64;
        if (repeatedInt64.length !== 0) {
          for (let i: i32 = 0; i < repeatedInt64.length; ++i) {
            writer.uint32(256);
            writer.int64(repeatedInt64[i]);
          }
        }

        const repeatedUint32 = message.repeatedUint32;
        if (repeatedUint32.length !== 0) {
          for (let i: i32 = 0; i < repeatedUint32.length; ++i) {
            writer.uint32(264);
            writer.uint32(repeatedUint32[i]);
          }
        }

        const repeatedUint64 = message.repeatedUint64;
        if (repeatedUint64.length !== 0) {
          for (let i: i32 = 0; i < repeatedUint64.length; ++i) {
            writer.uint32(272);
            writer.uint64(repeatedUint64[i]);
          }
        }

        const repeatedSint32 = message.repeatedSint32;
        if (repeatedSint32.length !== 0) {
          for (let i: i32 = 0; i < repeatedSint32.length; ++i) {
            writer.uint32(280);
            writer.sint32(repeatedSint32[i]);
          }
        }

        const repeatedSint64 = message.repeatedSint64;
        if (repeatedSint64.length !== 0) {
          for (let i: i32 = 0; i < repeatedSint64.length; ++i) {
            writer.uint32(288);
            writer.sint64(repeatedSint64[i]);
          }
        }

        const repeatedFixed32 = message.repeatedFixed32;
        if (repeatedFixed32.length !== 0) {
          for (let i: i32 = 0; i < repeatedFixed32.length; ++i) {
            writer.uint32(301);
            writer.fixed32(repeatedFixed32[i]);
          }
        }

        const repeatedFixed64 = message.repeatedFixed64;
        if (repeatedFixed64.length !== 0) {
          for (let i: i32 = 0; i < repeatedFixed64.length; ++i) {
            writer.uint32(305);
            writer.fixed64(repeatedFixed64[i]);
          }
        }

        const repeatedSfixed32 = message.repeatedSfixed32;
        if (repeatedSfixed32.length !== 0) {
          for (let i: i32 = 0; i < repeatedSfixed32.length; ++i) {
            writer.uint32(317);
            writer.sfixed32(repeatedSfixed32[i]);
          }
        }

        const repeatedSfixed64 = message.repeatedSfixed64;
        if (repeatedSfixed64.length !== 0) {
          for (let i: i32 = 0; i < repeatedSfixed64.length; ++i) {
            writer.uint32(321);
            writer.sfixed64(repeatedSfixed64[i]);
          }
        }

        const repeatedFloat = message.repeatedFloat;
        if (repeatedFloat.length !== 0) {
          for (let i: i32 = 0; i < repeatedFloat.length; ++i) {
            writer.uint32(333);
            writer.float(repeatedFloat[i]);
          }
        }

        const repeatedDouble = message.repeatedDouble;
        if (repeatedDouble.length !== 0) {
          for (let i: i32 = 0; i < repeatedDouble.length; ++i) {
            writer.uint32(337);
            writer.double(repeatedDouble[i]);
          }
        }

        const repeatedBool = message.repeatedBool;
        if (repeatedBool.length !== 0) {
          for (let i: i32 = 0; i < repeatedBool.length; ++i) {
            writer.uint32(344);
            writer.bool(repeatedBool[i]);
          }
        }

        const repeatedString = message.repeatedString;
        if (repeatedString.length !== 0) {
          for (let i: i32 = 0; i < repeatedString.length; ++i) {
            writer.uint32(354);
            writer.string(repeatedString[i]);
          }
        }

        const repeatedBytes = message.repeatedBytes;
        if (repeatedBytes.length !== 0) {
          for (let i: i32 = 0; i < repeatedBytes.length; ++i) {
            writer.uint32(362);
            writer.bytes(repeatedBytes[i]);
          }
        }

        const repeatedForeignMessage = message.repeatedForeignMessage;
        for (let i: i32 = 0; i < repeatedForeignMessage.length; ++i) {
          writer.uint32(394);
          writer.fork();
          asproto.test.ForeignMessage.encode(repeatedForeignMessage[i], writer);
          writer.ldelim();
        }

        const repeatedForeignEnum = message.repeatedForeignEnum;
        if (repeatedForeignEnum.length !== 0) {
          for (let i: i32 = 0; i < repeatedForeignEnum.length; ++i) {
            writer.uint32(416);
            writer.int32(repeatedForeignEnum[i]);
          }
        }
      }

      static decode(reader: Reader, length: i32): TestAllTypes {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestAllTypes();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 31:
              message.repeatedInt32.push(reader.int32());
              break;

            case 32:
              message.repeatedInt64.push(reader.int64());
              break;

            case 33:
              message.repeatedUint32.push(reader.uint32());
              break;

            case 34:
              message.repeatedUint64.push(reader.uint64());
              break;

            case 35:
              message.repeatedSint32.push(reader.sint32());
              break;

            case 36:
              message.repeatedSint64.push(reader.sint64());
              break;

            case 37:
              message.repeatedFixed32.push(reader.fixed32());
              break;

            case 38:
              message.repeatedFixed64.push(reader.fixed64());
              break;

            case 39:
              message.repeatedSfixed32.push(reader.sfixed32());
              break;

            case 40:
              message.repeatedSfixed64.push(reader.sfixed64());
              break;

            case 41:
              message.repeatedFloat.push(reader.float());
              break;

            case 42:
              message.repeatedDouble.push(reader.double());
              break;

            case 43:
              message.repeatedBool.push(reader.bool());
              break;

            case 44:
              message.repeatedString.push(reader.string());
              break;

            case 45:
              message.repeatedBytes.push(reader.bytes());
              break;

            case 49:
              message.repeatedForeignMessage.push(
                asproto.test.ForeignMessage.decode(reader, reader.uint32())
              );
              break;

            case 52:
              message.repeatedForeignEnum.push(reader.int32());
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      repeatedInt32: Array<i32>;
      repeatedInt64: Array<i64>;
      repeatedUint32: Array<u32>;
      repeatedUint64: Array<u64>;
      repeatedSint32: Array<i32>;
      repeatedSint64: Array<i64>;
      repeatedFixed32: Array<i32>;
      repeatedFixed64: Array<i64>;
      repeatedSfixed32: Array<i32>;
      repeatedSfixed64: Array<i64>;
      repeatedFloat: Array<f32>;
      repeatedDouble: Array<f64>;
      repeatedBool: Array<bool>;
      repeatedString: Array<string>;
      repeatedBytes: Array<Uint8Array>;
      repeatedForeignMessage: Array<asproto.test.ForeignMessage>;
      repeatedForeignEnum: Array<asproto.test.ForeignEnum>;

      constructor(
        repeatedInt32: Array<i32> = [],
        repeatedInt64: Array<i64> = [],
        repeatedUint32: Array<u32> = [],
        repeatedUint64: Array<u64> = [],
        repeatedSint32: Array<i32> = [],
        repeatedSint64: Array<i64> = [],
        repeatedFixed32: Array<i32> = [],
        repeatedFixed64: Array<i64> = [],
        repeatedSfixed32: Array<i32> = [],
        repeatedSfixed64: Array<i64> = [],
        repeatedFloat: Array<f32> = [],
        repeatedDouble: Array<f64> = [],
        repeatedBool: Array<bool> = [],
        repeatedString: Array<string> = [],
        repeatedBytes: Array<Uint8Array> = [],
        repeatedForeignMessage: Array<asproto.test.ForeignMessage> = [],
        repeatedForeignEnum: Array<asproto.test.ForeignEnum> = []
      ) {
        this.repeatedInt32 = repeatedInt32;
        this.repeatedInt64 = repeatedInt64;
        this.repeatedUint32 = repeatedUint32;
        this.repeatedUint64 = repeatedUint64;
        this.repeatedSint32 = repeatedSint32;
        this.repeatedSint64 = repeatedSint64;
        this.repeatedFixed32 = repeatedFixed32;
        this.repeatedFixed64 = repeatedFixed64;
        this.repeatedSfixed32 = repeatedSfixed32;
        this.repeatedSfixed64 = repeatedSfixed64;
        this.repeatedFloat = repeatedFloat;
        this.repeatedDouble = repeatedDouble;
        this.repeatedBool = repeatedBool;
        this.repeatedString = repeatedString;
        this.repeatedBytes = repeatedBytes;
        this.repeatedForeignMessage = repeatedForeignMessage;
        this.repeatedForeignEnum = repeatedForeignEnum;
      }
    }

    @unmanaged
    export class ForeignMessage {
      static encode(message: ForeignMessage, writer: Writer): void {
        writer.uint32(8);
        writer.int32(message.c);
      }

      static decode(reader: Reader, length: i32): ForeignMessage {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new ForeignMessage();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.c = reader.int32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      c: i32;

      constructor(c: i32 = 0) {
        this.c = c;
      }
    }

    @unmanaged
    export class TestExtendable {
      static encode(message: TestExtendable, writer: Writer): void {}

      static decode(reader: Reader, length: i32): TestExtendable {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestExtendable();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      constructor() {}
    }

    @unmanaged
    export class ExtendsWithMessage {
      static encode(message: ExtendsWithMessage, writer: Writer): void {
        writer.uint32(8);
        writer.int32(message.foo);
      }

      static decode(reader: Reader, length: i32): ExtendsWithMessage {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new ExtendsWithMessage();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.foo = reader.int32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      foo: i32;

      constructor(foo: i32 = 0) {
        this.foo = foo;
      }
    }

    export class TestMapFields {
      static encode(message: TestMapFields, writer: Writer): void {
        const mapStringString = message.mapStringString;
        if (mapStringString !== null) {
          const mapStringStringKeys = mapStringString.keys();
          for (let i: i32 = 0; i < mapStringStringKeys.length; ++i) {
            const mapStringStringKey = mapStringStringKeys[i];
            writer.uint32(10);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringStringKey);
            writer.uint32(18);
            writer.string(mapStringString.get(mapStringStringKey));
            writer.ldelim();
          }
        }

        const mapStringInt32 = message.mapStringInt32;
        if (mapStringInt32 !== null) {
          const mapStringInt32Keys = mapStringInt32.keys();
          for (let i: i32 = 0; i < mapStringInt32Keys.length; ++i) {
            const mapStringInt32Key = mapStringInt32Keys[i];
            writer.uint32(18);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringInt32Key);
            writer.uint32(16);
            writer.int32(mapStringInt32.get(mapStringInt32Key));
            writer.ldelim();
          }
        }

        const mapStringInt64 = message.mapStringInt64;
        if (mapStringInt64 !== null) {
          const mapStringInt64Keys = mapStringInt64.keys();
          for (let i: i32 = 0; i < mapStringInt64Keys.length; ++i) {
            const mapStringInt64Key = mapStringInt64Keys[i];
            writer.uint32(26);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringInt64Key);
            writer.uint32(16);
            writer.int64(mapStringInt64.get(mapStringInt64Key));
            writer.ldelim();
          }
        }

        const mapStringBool = message.mapStringBool;
        if (mapStringBool !== null) {
          const mapStringBoolKeys = mapStringBool.keys();
          for (let i: i32 = 0; i < mapStringBoolKeys.length; ++i) {
            const mapStringBoolKey = mapStringBoolKeys[i];
            writer.uint32(34);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringBoolKey);
            writer.uint32(16);
            writer.bool(mapStringBool.get(mapStringBoolKey));
            writer.ldelim();
          }
        }

        const mapStringDouble = message.mapStringDouble;
        if (mapStringDouble !== null) {
          const mapStringDoubleKeys = mapStringDouble.keys();
          for (let i: i32 = 0; i < mapStringDoubleKeys.length; ++i) {
            const mapStringDoubleKey = mapStringDoubleKeys[i];
            writer.uint32(42);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringDoubleKey);
            writer.uint32(17);
            writer.double(mapStringDouble.get(mapStringDoubleKey));
            writer.ldelim();
          }
        }

        const mapStringEnum = message.mapStringEnum;
        if (mapStringEnum !== null) {
          const mapStringEnumKeys = mapStringEnum.keys();
          for (let i: i32 = 0; i < mapStringEnumKeys.length; ++i) {
            const mapStringEnumKey = mapStringEnumKeys[i];
            writer.uint32(50);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringEnumKey);
            writer.uint32(16);
            writer.int32(mapStringEnum.get(mapStringEnumKey));
            writer.ldelim();
          }
        }

        const mapStringMsg = message.mapStringMsg;
        if (mapStringMsg !== null) {
          const mapStringMsgKeys = mapStringMsg.keys();
          for (let i: i32 = 0; i < mapStringMsgKeys.length; ++i) {
            const mapStringMsgKey = mapStringMsgKeys[i];
            writer.uint32(58);
            writer.fork();
            writer.uint32(10);
            writer.string(mapStringMsgKey);
            writer.uint32(18);
            writer.fork();
            asproto.test.MapValueMessage.encode(
              mapStringMsg.get(mapStringMsgKey),
              writer
            );
            writer.ldelim();
            writer.ldelim();
          }
        }

        const mapInt32String = message.mapInt32String;
        if (mapInt32String !== null) {
          const mapInt32StringKeys = mapInt32String.keys();
          for (let i: i32 = 0; i < mapInt32StringKeys.length; ++i) {
            const mapInt32StringKey = mapInt32StringKeys[i];
            writer.uint32(66);
            writer.fork();
            writer.uint32(8);
            writer.int32(mapInt32StringKey);
            writer.uint32(18);
            writer.string(mapInt32String.get(mapInt32StringKey));
            writer.ldelim();
          }
        }

        const mapInt64String = message.mapInt64String;
        if (mapInt64String !== null) {
          const mapInt64StringKeys = mapInt64String.keys();
          for (let i: i32 = 0; i < mapInt64StringKeys.length; ++i) {
            const mapInt64StringKey = mapInt64StringKeys[i];
            writer.uint32(74);
            writer.fork();
            writer.uint32(8);
            writer.int64(mapInt64StringKey);
            writer.uint32(18);
            writer.string(mapInt64String.get(mapInt64StringKey));
            writer.ldelim();
          }
        }

        const mapBoolString = message.mapBoolString;
        if (mapBoolString !== null) {
          const mapBoolStringKeys = mapBoolString.keys();
          for (let i: i32 = 0; i < mapBoolStringKeys.length; ++i) {
            const mapBoolStringKey = mapBoolStringKeys[i];
            writer.uint32(82);
            writer.fork();
            writer.uint32(8);
            writer.bool(mapBoolStringKey);
            writer.uint32(18);
            writer.string(mapBoolString.get(mapBoolStringKey));
            writer.ldelim();
          }
        }
      }

      static decode(reader: Reader, length: i32): TestMapFields {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestMapFields();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              let mapStringStringKey: string = "";
              let mapStringStringValue: string = "";
              let mapStringStringHasKey: bool = false;
              let mapStringStringHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringStringKey = reader.string();
                    mapStringStringHasKey = true;
                    break;

                  case 2:
                    mapStringStringValue = reader.string();
                    mapStringStringHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringString === null) {
                  message.mapStringString = new Map<string, string>();
                }
                const mapStringString = message.mapStringString;
                if (
                  mapStringString !== null &&
                  mapStringStringHasKey &&
                  mapStringStringHasValue
                ) {
                  mapStringString.set(mapStringStringKey, mapStringStringValue);
                }
              }
              break;

            case 2:
              let mapStringInt32Key: string = "";
              let mapStringInt32Value: i32 = 0;
              let mapStringInt32HasKey: bool = false;
              let mapStringInt32HasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringInt32Key = reader.string();
                    mapStringInt32HasKey = true;
                    break;

                  case 2:
                    mapStringInt32Value = reader.int32();
                    mapStringInt32HasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringInt32 === null) {
                  message.mapStringInt32 = new Map<string, i32>();
                }
                const mapStringInt32 = message.mapStringInt32;
                if (
                  mapStringInt32 !== null &&
                  mapStringInt32HasKey &&
                  mapStringInt32HasValue
                ) {
                  mapStringInt32.set(mapStringInt32Key, mapStringInt32Value);
                }
              }
              break;

            case 3:
              let mapStringInt64Key: string = "";
              let mapStringInt64Value: i64 = 0;
              let mapStringInt64HasKey: bool = false;
              let mapStringInt64HasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringInt64Key = reader.string();
                    mapStringInt64HasKey = true;
                    break;

                  case 2:
                    mapStringInt64Value = reader.int64();
                    mapStringInt64HasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringInt64 === null) {
                  message.mapStringInt64 = new Map<string, i64>();
                }
                const mapStringInt64 = message.mapStringInt64;
                if (
                  mapStringInt64 !== null &&
                  mapStringInt64HasKey &&
                  mapStringInt64HasValue
                ) {
                  mapStringInt64.set(mapStringInt64Key, mapStringInt64Value);
                }
              }
              break;

            case 4:
              let mapStringBoolKey: string = "";
              let mapStringBoolValue: bool = false;
              let mapStringBoolHasKey: bool = false;
              let mapStringBoolHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringBoolKey = reader.string();
                    mapStringBoolHasKey = true;
                    break;

                  case 2:
                    mapStringBoolValue = reader.bool();
                    mapStringBoolHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringBool === null) {
                  message.mapStringBool = new Map<string, bool>();
                }
                const mapStringBool = message.mapStringBool;
                if (
                  mapStringBool !== null &&
                  mapStringBoolHasKey &&
                  mapStringBoolHasValue
                ) {
                  mapStringBool.set(mapStringBoolKey, mapStringBoolValue);
                }
              }
              break;

            case 5:
              let mapStringDoubleKey: string = "";
              let mapStringDoubleValue: f64 = 0.0;
              let mapStringDoubleHasKey: bool = false;
              let mapStringDoubleHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringDoubleKey = reader.string();
                    mapStringDoubleHasKey = true;
                    break;

                  case 2:
                    mapStringDoubleValue = reader.double();
                    mapStringDoubleHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringDouble === null) {
                  message.mapStringDouble = new Map<string, f64>();
                }
                const mapStringDouble = message.mapStringDouble;
                if (
                  mapStringDouble !== null &&
                  mapStringDoubleHasKey &&
                  mapStringDoubleHasValue
                ) {
                  mapStringDouble.set(mapStringDoubleKey, mapStringDoubleValue);
                }
              }
              break;

            case 6:
              let mapStringEnumKey: string = "";
              let mapStringEnumValue: asproto.test.MapValueEnum = 0;
              let mapStringEnumHasKey: bool = false;
              let mapStringEnumHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringEnumKey = reader.string();
                    mapStringEnumHasKey = true;
                    break;

                  case 2:
                    mapStringEnumValue = reader.int32();
                    mapStringEnumHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringEnum === null) {
                  message.mapStringEnum = new Map<
                    string,
                    asproto.test.MapValueEnum
                  >();
                }
                const mapStringEnum = message.mapStringEnum;
                if (
                  mapStringEnum !== null &&
                  mapStringEnumHasKey &&
                  mapStringEnumHasValue
                ) {
                  mapStringEnum.set(mapStringEnumKey, mapStringEnumValue);
                }
              }
              break;

            case 7:
              let mapStringMsgKey: string = "";
              let mapStringMsgValue: asproto.test.MapValueMessage | null = null;
              let mapStringMsgHasKey: bool = false;
              let mapStringMsgHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapStringMsgKey = reader.string();
                    mapStringMsgHasKey = true;
                    break;

                  case 2:
                    mapStringMsgValue = asproto.test.MapValueMessage.decode(
                      reader,
                      reader.uint32()
                    );
                    mapStringMsgHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapStringMsg === null) {
                  message.mapStringMsg = new Map<
                    string,
                    asproto.test.MapValueMessage
                  >();
                }
                const mapStringMsg = message.mapStringMsg;
                if (
                  mapStringMsg !== null &&
                  mapStringMsgHasKey &&
                  mapStringMsgHasValue &&
                  mapStringMsgValue !== null
                ) {
                  mapStringMsg.set(mapStringMsgKey, mapStringMsgValue);
                }
              }
              break;

            case 8:
              let mapInt32StringKey: i32 = 0;
              let mapInt32StringValue: string = "";
              let mapInt32StringHasKey: bool = false;
              let mapInt32StringHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapInt32StringKey = reader.int32();
                    mapInt32StringHasKey = true;
                    break;

                  case 2:
                    mapInt32StringValue = reader.string();
                    mapInt32StringHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapInt32String === null) {
                  message.mapInt32String = new Map<i32, string>();
                }
                const mapInt32String = message.mapInt32String;
                if (
                  mapInt32String !== null &&
                  mapInt32StringHasKey &&
                  mapInt32StringHasValue
                ) {
                  mapInt32String.set(mapInt32StringKey, mapInt32StringValue);
                }
              }
              break;

            case 9:
              let mapInt64StringKey: i64 = 0;
              let mapInt64StringValue: string = "";
              let mapInt64StringHasKey: bool = false;
              let mapInt64StringHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapInt64StringKey = reader.int64();
                    mapInt64StringHasKey = true;
                    break;

                  case 2:
                    mapInt64StringValue = reader.string();
                    mapInt64StringHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapInt64String === null) {
                  message.mapInt64String = new Map<i64, string>();
                }
                const mapInt64String = message.mapInt64String;
                if (
                  mapInt64String !== null &&
                  mapInt64StringHasKey &&
                  mapInt64StringHasValue
                ) {
                  mapInt64String.set(mapInt64StringKey, mapInt64StringValue);
                }
              }
              break;

            case 10:
              let mapBoolStringKey: bool = false;
              let mapBoolStringValue: string = "";
              let mapBoolStringHasKey: bool = false;
              let mapBoolStringHasValue: bool = false;
              for (
                const end: usize = reader.ptr + reader.uint32();
                reader.ptr < end;

              ) {
                const tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    mapBoolStringKey = reader.bool();
                    mapBoolStringHasKey = true;
                    break;

                  case 2:
                    mapBoolStringValue = reader.string();
                    mapBoolStringHasValue = true;
                    break;

                  default:
                    reader.skipType(tag & 7);
                    break;
                }
                if (message.mapBoolString === null) {
                  message.mapBoolString = new Map<bool, string>();
                }
                const mapBoolString = message.mapBoolString;
                if (
                  mapBoolString !== null &&
                  mapBoolStringHasKey &&
                  mapBoolStringHasValue
                ) {
                  mapBoolString.set(mapBoolStringKey, mapBoolStringValue);
                }
              }
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      mapStringString: Map<string, string>;
      mapStringInt32: Map<string, i32>;
      mapStringInt64: Map<string, i64>;
      mapStringBool: Map<string, bool>;
      mapStringDouble: Map<string, f64>;
      mapStringEnum: Map<string, asproto.test.MapValueEnum>;
      mapStringMsg: Map<string, asproto.test.MapValueMessage>;
      mapInt32String: Map<i32, string>;
      mapInt64String: Map<i64, string>;
      mapBoolString: Map<bool, string>;

      constructor(
        mapStringString: Map<string, string> = new Map(),
        mapStringInt32: Map<string, i32> = new Map(),
        mapStringInt64: Map<string, i64> = new Map(),
        mapStringBool: Map<string, bool> = new Map(),
        mapStringDouble: Map<string, f64> = new Map(),
        mapStringEnum: Map<string, asproto.test.MapValueEnum> = new Map(),
        mapStringMsg: Map<string, asproto.test.MapValueMessage> = new Map(),
        mapInt32String: Map<i32, string> = new Map(),
        mapInt64String: Map<i64, string> = new Map(),
        mapBoolString: Map<bool, string> = new Map()
      ) {
        this.mapStringString = mapStringString;
        this.mapStringInt32 = mapStringInt32;
        this.mapStringInt64 = mapStringInt64;
        this.mapStringBool = mapStringBool;
        this.mapStringDouble = mapStringDouble;
        this.mapStringEnum = mapStringEnum;
        this.mapStringMsg = mapStringMsg;
        this.mapInt32String = mapInt32String;
        this.mapInt64String = mapInt64String;
        this.mapBoolString = mapBoolString;
      }
    }

    export namespace TestMapFields {}

    export class MapEntryOptionalKeysStringKey {
      static encode(
        message: MapEntryOptionalKeysStringKey,
        writer: Writer
      ): void {
        writer.uint32(10);
        writer.string(message.key);

        writer.uint32(18);
        writer.string(message.value);
      }

      static decode(
        reader: Reader,
        length: i32
      ): MapEntryOptionalKeysStringKey {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapEntryOptionalKeysStringKey();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;

            case 2:
              message.value = reader.string();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      key: string;
      value: string;

      constructor(key: string = "", value: string = "") {
        this.key = key;
        this.value = value;
      }
    }

    export class MapEntryOptionalKeysInt32Key {
      static encode(
        message: MapEntryOptionalKeysInt32Key,
        writer: Writer
      ): void {
        writer.uint32(8);
        writer.int32(message.key);

        writer.uint32(18);
        writer.string(message.value);
      }

      static decode(reader: Reader, length: i32): MapEntryOptionalKeysInt32Key {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapEntryOptionalKeysInt32Key();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.int32();
              break;

            case 2:
              message.value = reader.string();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      key: i32;
      value: string;

      constructor(key: i32 = 0, value: string = "") {
        this.key = key;
        this.value = value;
      }
    }

    export class MapEntryOptionalKeysInt64Key {
      static encode(
        message: MapEntryOptionalKeysInt64Key,
        writer: Writer
      ): void {
        writer.uint32(8);
        writer.int64(message.key);

        writer.uint32(18);
        writer.string(message.value);
      }

      static decode(reader: Reader, length: i32): MapEntryOptionalKeysInt64Key {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapEntryOptionalKeysInt64Key();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.int64();
              break;

            case 2:
              message.value = reader.string();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      key: i64;
      value: string;

      constructor(key: i64 = 0, value: string = "") {
        this.key = key;
        this.value = value;
      }
    }

    export class MapEntryOptionalKeysBoolKey {
      static encode(
        message: MapEntryOptionalKeysBoolKey,
        writer: Writer
      ): void {
        writer.uint32(8);
        writer.bool(message.key);

        writer.uint32(18);
        writer.string(message.value);
      }

      static decode(reader: Reader, length: i32): MapEntryOptionalKeysBoolKey {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapEntryOptionalKeysBoolKey();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bool();
              break;

            case 2:
              message.value = reader.string();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      key: bool;
      value: string;

      constructor(key: bool = false, value: string = "") {
        this.key = key;
        this.value = value;
      }
    }

    export class TestMapFieldsOptionalKeys {
      static encode(message: TestMapFieldsOptionalKeys, writer: Writer): void {
        const mapStringString = message.mapStringString;
        if (mapStringString !== null) {
          writer.uint32(10);
          writer.fork();
          asproto.test.MapEntryOptionalKeysStringKey.encode(
            mapStringString,
            writer
          );
          writer.ldelim();
        }

        const mapInt32String = message.mapInt32String;
        if (mapInt32String !== null) {
          writer.uint32(66);
          writer.fork();
          asproto.test.MapEntryOptionalKeysInt32Key.encode(
            mapInt32String,
            writer
          );
          writer.ldelim();
        }

        const mapInt64String = message.mapInt64String;
        if (mapInt64String !== null) {
          writer.uint32(74);
          writer.fork();
          asproto.test.MapEntryOptionalKeysInt64Key.encode(
            mapInt64String,
            writer
          );
          writer.ldelim();
        }

        const mapBoolString = message.mapBoolString;
        if (mapBoolString !== null) {
          writer.uint32(82);
          writer.fork();
          asproto.test.MapEntryOptionalKeysBoolKey.encode(
            mapBoolString,
            writer
          );
          writer.ldelim();
        }
      }

      static decode(reader: Reader, length: i32): TestMapFieldsOptionalKeys {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestMapFieldsOptionalKeys();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mapStringString =
                asproto.test.MapEntryOptionalKeysStringKey.decode(
                  reader,
                  reader.uint32()
                );
              break;

            case 8:
              message.mapInt32String =
                asproto.test.MapEntryOptionalKeysInt32Key.decode(
                  reader,
                  reader.uint32()
                );
              break;

            case 9:
              message.mapInt64String =
                asproto.test.MapEntryOptionalKeysInt64Key.decode(
                  reader,
                  reader.uint32()
                );
              break;

            case 10:
              message.mapBoolString =
                asproto.test.MapEntryOptionalKeysBoolKey.decode(
                  reader,
                  reader.uint32()
                );
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      mapStringString: asproto.test.MapEntryOptionalKeysStringKey | null;
      mapInt32String: asproto.test.MapEntryOptionalKeysInt32Key | null;
      mapInt64String: asproto.test.MapEntryOptionalKeysInt64Key | null;
      mapBoolString: asproto.test.MapEntryOptionalKeysBoolKey | null;

      constructor(
        mapStringString: asproto.test.MapEntryOptionalKeysStringKey | null = null,
        mapInt32String: asproto.test.MapEntryOptionalKeysInt32Key | null = null,
        mapInt64String: asproto.test.MapEntryOptionalKeysInt64Key | null = null,
        mapBoolString: asproto.test.MapEntryOptionalKeysBoolKey | null = null
      ) {
        this.mapStringString = mapStringString;
        this.mapInt32String = mapInt32String;
        this.mapInt64String = mapInt64String;
        this.mapBoolString = mapBoolString;
      }
    }

    export class MapEntryOptionalValuesStringValue {
      static encode(
        message: MapEntryOptionalValuesStringValue,
        writer: Writer
      ): void {
        writer.uint32(10);
        writer.string(message.key);

        writer.uint32(18);
        writer.string(message.value);
      }

      static decode(
        reader: Reader,
        length: i32
      ): MapEntryOptionalValuesStringValue {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapEntryOptionalValuesStringValue();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;

            case 2:
              message.value = reader.string();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      key: string;
      value: string;

      constructor(key: string = "", value: string = "") {
        this.key = key;
        this.value = value;
      }
    }

    export class MapEntryOptionalValuesInt32Value {
      static encode(
        message: MapEntryOptionalValuesInt32Value,
        writer: Writer
      ): void {
        writer.uint32(10);
        writer.string(message.key);

        writer.uint32(16);
        writer.int32(message.value);
      }

      static decode(
        reader: Reader,
        length: i32
      ): MapEntryOptionalValuesInt32Value {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapEntryOptionalValuesInt32Value();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;

            case 2:
              message.value = reader.int32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      key: string;
      value: i32;

      constructor(key: string = "", value: i32 = 0) {
        this.key = key;
        this.value = value;
      }
    }

    export class MapEntryOptionalValuesInt64Value {
      static encode(
        message: MapEntryOptionalValuesInt64Value,
        writer: Writer
      ): void {
        writer.uint32(10);
        writer.string(message.key);

        writer.uint32(16);
        writer.int64(message.value);
      }

      static decode(
        reader: Reader,
        length: i32
      ): MapEntryOptionalValuesInt64Value {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapEntryOptionalValuesInt64Value();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;

            case 2:
              message.value = reader.int64();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      key: string;
      value: i64;

      constructor(key: string = "", value: i64 = 0) {
        this.key = key;
        this.value = value;
      }
    }

    export class MapEntryOptionalValuesBoolValue {
      static encode(
        message: MapEntryOptionalValuesBoolValue,
        writer: Writer
      ): void {
        writer.uint32(10);
        writer.string(message.key);

        writer.uint32(16);
        writer.bool(message.value);
      }

      static decode(
        reader: Reader,
        length: i32
      ): MapEntryOptionalValuesBoolValue {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapEntryOptionalValuesBoolValue();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;

            case 2:
              message.value = reader.bool();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      key: string;
      value: bool;

      constructor(key: string = "", value: bool = false) {
        this.key = key;
        this.value = value;
      }
    }

    export class MapEntryOptionalValuesDoubleValue {
      static encode(
        message: MapEntryOptionalValuesDoubleValue,
        writer: Writer
      ): void {
        writer.uint32(10);
        writer.string(message.key);

        writer.uint32(17);
        writer.double(message.value);
      }

      static decode(
        reader: Reader,
        length: i32
      ): MapEntryOptionalValuesDoubleValue {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapEntryOptionalValuesDoubleValue();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;

            case 2:
              message.value = reader.double();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      key: string;
      value: f64;

      constructor(key: string = "", value: f64 = 0.0) {
        this.key = key;
        this.value = value;
      }
    }

    export class MapEntryOptionalValuesEnumValue {
      static encode(
        message: MapEntryOptionalValuesEnumValue,
        writer: Writer
      ): void {
        writer.uint32(10);
        writer.string(message.key);

        writer.uint32(16);
        writer.int32(message.value);
      }

      static decode(
        reader: Reader,
        length: i32
      ): MapEntryOptionalValuesEnumValue {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapEntryOptionalValuesEnumValue();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;

            case 2:
              message.value = reader.int32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      key: string;
      value: asproto.test.MapValueEnum;

      constructor(key: string = "", value: asproto.test.MapValueEnum = 0) {
        this.key = key;
        this.value = value;
      }
    }

    export class MapEntryOptionalValuesMessageValue {
      static encode(
        message: MapEntryOptionalValuesMessageValue,
        writer: Writer
      ): void {
        writer.uint32(10);
        writer.string(message.key);

        const value = message.value;
        if (value !== null) {
          writer.uint32(18);
          writer.fork();
          asproto.test.MapValueMessage.encode(value, writer);
          writer.ldelim();
        }
      }

      static decode(
        reader: Reader,
        length: i32
      ): MapEntryOptionalValuesMessageValue {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapEntryOptionalValuesMessageValue();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;

            case 2:
              message.value = asproto.test.MapValueMessage.decode(
                reader,
                reader.uint32()
              );
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      key: string;
      value: asproto.test.MapValueMessage | null;

      constructor(
        key: string = "",
        value: asproto.test.MapValueMessage | null = null
      ) {
        this.key = key;
        this.value = value;
      }
    }

    export class TestMapFieldsOptionalValues {
      static encode(
        message: TestMapFieldsOptionalValues,
        writer: Writer
      ): void {
        const mapStringString = message.mapStringString;
        if (mapStringString !== null) {
          writer.uint32(10);
          writer.fork();
          asproto.test.MapEntryOptionalValuesStringValue.encode(
            mapStringString,
            writer
          );
          writer.ldelim();
        }

        const mapStringInt32 = message.mapStringInt32;
        if (mapStringInt32 !== null) {
          writer.uint32(18);
          writer.fork();
          asproto.test.MapEntryOptionalValuesInt32Value.encode(
            mapStringInt32,
            writer
          );
          writer.ldelim();
        }

        const mapStringInt64 = message.mapStringInt64;
        if (mapStringInt64 !== null) {
          writer.uint32(26);
          writer.fork();
          asproto.test.MapEntryOptionalValuesInt64Value.encode(
            mapStringInt64,
            writer
          );
          writer.ldelim();
        }

        const mapStringBool = message.mapStringBool;
        if (mapStringBool !== null) {
          writer.uint32(34);
          writer.fork();
          asproto.test.MapEntryOptionalValuesBoolValue.encode(
            mapStringBool,
            writer
          );
          writer.ldelim();
        }

        const mapStringDouble = message.mapStringDouble;
        if (mapStringDouble !== null) {
          writer.uint32(42);
          writer.fork();
          asproto.test.MapEntryOptionalValuesDoubleValue.encode(
            mapStringDouble,
            writer
          );
          writer.ldelim();
        }

        const mapStringEnum = message.mapStringEnum;
        if (mapStringEnum !== null) {
          writer.uint32(50);
          writer.fork();
          asproto.test.MapEntryOptionalValuesEnumValue.encode(
            mapStringEnum,
            writer
          );
          writer.ldelim();
        }

        const mapStringMsg = message.mapStringMsg;
        if (mapStringMsg !== null) {
          writer.uint32(58);
          writer.fork();
          asproto.test.MapEntryOptionalValuesMessageValue.encode(
            mapStringMsg,
            writer
          );
          writer.ldelim();
        }
      }

      static decode(reader: Reader, length: i32): TestMapFieldsOptionalValues {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new TestMapFieldsOptionalValues();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mapStringString =
                asproto.test.MapEntryOptionalValuesStringValue.decode(
                  reader,
                  reader.uint32()
                );
              break;

            case 2:
              message.mapStringInt32 =
                asproto.test.MapEntryOptionalValuesInt32Value.decode(
                  reader,
                  reader.uint32()
                );
              break;

            case 3:
              message.mapStringInt64 =
                asproto.test.MapEntryOptionalValuesInt64Value.decode(
                  reader,
                  reader.uint32()
                );
              break;

            case 4:
              message.mapStringBool =
                asproto.test.MapEntryOptionalValuesBoolValue.decode(
                  reader,
                  reader.uint32()
                );
              break;

            case 5:
              message.mapStringDouble =
                asproto.test.MapEntryOptionalValuesDoubleValue.decode(
                  reader,
                  reader.uint32()
                );
              break;

            case 6:
              message.mapStringEnum =
                asproto.test.MapEntryOptionalValuesEnumValue.decode(
                  reader,
                  reader.uint32()
                );
              break;

            case 7:
              message.mapStringMsg =
                asproto.test.MapEntryOptionalValuesMessageValue.decode(
                  reader,
                  reader.uint32()
                );
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      mapStringString: asproto.test.MapEntryOptionalValuesStringValue | null;
      mapStringInt32: asproto.test.MapEntryOptionalValuesInt32Value | null;
      mapStringInt64: asproto.test.MapEntryOptionalValuesInt64Value | null;
      mapStringBool: asproto.test.MapEntryOptionalValuesBoolValue | null;
      mapStringDouble: asproto.test.MapEntryOptionalValuesDoubleValue | null;
      mapStringEnum: asproto.test.MapEntryOptionalValuesEnumValue | null;
      mapStringMsg: asproto.test.MapEntryOptionalValuesMessageValue | null;

      constructor(
        mapStringString: asproto.test.MapEntryOptionalValuesStringValue | null = null,
        mapStringInt32: asproto.test.MapEntryOptionalValuesInt32Value | null = null,
        mapStringInt64: asproto.test.MapEntryOptionalValuesInt64Value | null = null,
        mapStringBool: asproto.test.MapEntryOptionalValuesBoolValue | null = null,
        mapStringDouble: asproto.test.MapEntryOptionalValuesDoubleValue | null = null,
        mapStringEnum: asproto.test.MapEntryOptionalValuesEnumValue | null = null,
        mapStringMsg: asproto.test.MapEntryOptionalValuesMessageValue | null = null
      ) {
        this.mapStringString = mapStringString;
        this.mapStringInt32 = mapStringInt32;
        this.mapStringInt64 = mapStringInt64;
        this.mapStringBool = mapStringBool;
        this.mapStringDouble = mapStringDouble;
        this.mapStringEnum = mapStringEnum;
        this.mapStringMsg = mapStringMsg;
      }
    }

    @unmanaged
    export class MapValueMessage {
      static encode(message: MapValueMessage, writer: Writer): void {
        writer.uint32(8);
        writer.int32(message.foo);
      }

      static decode(reader: Reader, length: i32): MapValueMessage {
        const end: usize = length < 0 ? reader.end : reader.ptr + length;
        const message = new MapValueMessage();

        while (reader.ptr < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.foo = reader.int32();
              break;

            default:
              reader.skipType(tag & 7);
              break;
          }
        }

        return message;
      }

      foo: i32;

      constructor(foo: i32 = 0) {
        this.foo = foo;
      }
    }

    export enum ForeignEnum {
      FOREIGN_FOO = 4,
      FOREIGN_BAR = 5,
      FOREIGN_BAZ = 6,
    }

    export enum MapValueEnum {
      MAP_VALUE_FOO = 0,
      MAP_VALUE_BAR = 1,
      MAP_VALUE_BAZ = 2,
    }
  }
}
